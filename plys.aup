#include <ProcessConstants.au3>
#include <TrayConstants.au3>
#include <WinAPIHObj.au3>
#include <WinAPIProc.au3>
#include <WinAPISys.au3>
Opt("MustDeclareVars", 1)

enum CommentType, DirectiveType, StringType, LambdaType, MainType
enum IncludeDep = 2, MirIncludeDep = 1.5, ImportDep = 1

; Translation settings
const LambdaNameLen = 16
const ABC = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", _
    "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "0", _
    "1", "2", "3", "4", "5", "6", "7", "8", "9"]
const TabInSpaces = "    "
const ModulePublicSuffixRegEx = "\*"
const NewSuffixLen = 2
const NameDelimRegEx = ":"

; Default project settings
dim StdioExchange = True
dim LambdaFunctions = False
dim NoDollarPrefix = True
dim ConstByDefault = True
dim CloseBlockByIndent = True
dim ImportKeyword = True
dim Synonyms = True

; Translator options
dim RunMode = True
dim ErrorStdOut = False
dim RapidMode = False
dim InputFilePath
dim InputFileDir

; Table of dependencies
;    Array size: DepTable[n+1][n+1]
;    Array structure:
;       DepTable[0][0] = n                number of files
;       DepTable[1..n][0]                  relative path to file “n”
;       DepTable[0][1..n]                  names array of file “n”
;       DepTable[i][j] = include        file “i” includes file “j”
dim DepTable[1][1] = [[0]]

; Table of visibilities: which module sees names from which module
; (based on DepTable)
dim ThruTable

dim PathsToDeleteOnExit[0]


Main()


func Main*()
    const scriptArgs = ProcessCmdLine()
    GetProjectSettings()

    TraySetIcon("stop")
    TraySetState(TRAY_ICONSTATE_FLASH)

    const rel_path = PathPart(InputFilePath, "name", "ext")
    GetDeps(DepTable, rel_path)
    if not RunMode then Echo("[Dependencies are get]" . @)

    if ImportKeyword then MakeThruTable()

    ProcessFiles()

    DepTable = 0
    if ImportKeyword then ThruTable = 0

    if RunMode then
        const pid = Run('"' . @AutoItExe _
            . (ErrorStdOut? '" /ErrorStdOut "' : '" "') . InputFilePath _
            . '.au3" ' . scriptArgs, "", default, _
            STDIN_CHILD + STDERR_CHILD + STDOUT_CHILD)
        if StdioExchange then
            Opt("TrayIconHide", 1)
            ProcessStdio(pid)


func ProcessCmdLine()
; @CmdLine = [0:n, 1:path, 2:args] or [0:n, 1:/ErrorStdOut, 2:path, 3:args]
    const pathIndex = _GetPathIndex()
    if pathIndex = 0 then
        InputFilePath = OpenDialog("Run Script:", @MyDocumentsDir, _
            "Plys script files (*.aup)|All files (*.*)")
        ; TODO: AutoIt script files (*.au3;*.a3x)
        if @error then exit
    else
        InputFilePath = @CmdLine[pathIndex]

    InputFileDir = PathPart(InputFilePath, "drive", "dir")

    const argc = @CmdLine[0] - pathIndex
    if argc = 0 then return ""
    dim argv[argc]
    for i = pathIndex + 1 to @CmdLine[0]
        argv[i - 2] = '"' . @CmdLine[i] . '"'
    return _ArrayToString(argv, " ")


func _GetPathIndex()
    if @CmdLine[0] = 0 then return 0
    for i = 1 to @CmdLine[0]
        if Left(@CmdLine[i], 1) <> "/" then exitloop
        switch @CmdLine[i]
            case "/Translate"
                RunMode = False
            case "/ErrorStdOut"
                ErrorStdOut = True
            case "/Rapid"
                RapidMode = True
    return i


func GetProjectSettings()
    const text = Read(InputFilePath)
    StdioExchange = StdioExchange _
        and not ReFind(text, "(?m)^\#plys nostdio")
    LambdaFunctions = LambdaFunctions _
        or ReFind(text, "(?m)^\#plys lambda")
    NoDollarPrefix = NoDollarPrefix _
        and not ReFind(text, "(?m)^\#plys dollarprefix")
    ConstByDefault = ConstByDefault _
        and not ReFind(text, "(?m)^\#plys noconst")
    CloseBlockByIndent = CloseBlockByIndent _
        and not ReFind(text, "(?m)^\#plys noindent")
    ImportKeyword = ImportKeyword _
        and not ReFind(text, "(?m)^\#plys noimport")
    Synonyms = Synonyms _
        and not ReFind(text, "(?m)^\#plys nosynonyms")


;−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
func MakeThruTable()
;−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
    ThruTable = DepTable
    
    ; capture dependencies throught
    dim changed
    do
        changed = False
        for row = 1 to ThruTable[0][0]
            for col = 1 to ThruTable[0][0]
                switch ThruTable[row][col]
                    case IncludeDep ; −−−−−−−−−−−−−−−−−−−−−−−−−−−−
                        ; “mirror” rule
                        if ThruTable[col][row] <= ImportDep then
                            ThruTable[col][row] = MirIncludeDep
                            changed = True
                        ; “chain” rule for column
                        for y = 1 to ThruTable[0][0]
                            if y <> col _
                                and ThruTable[y][row] > ThruTable[y][col] _
                            then
                                ThruTable[y][col] = ThruTable[y][row]
                                changed = True
                    case ImportDep ; −−−−−−−−−−−−−−−−−−−−−−−−−−−−−
                        ; “chain” rule for column
                        for y = 1 to ThruTable[0][0]
                            if y <> col _
                                and ThruTable[y][row] > ImportDep _
                                and ThruTable[y][col] = "" _
                            then
                                ThruTable[y][col] = ImportDep
                                changed = True
                endswitch
            next col
        next row
    until not changed


; ATTENTION: not used
func RandomStrings(abc, num, stringsLen)
    dim strings[num + 1]
    dim str
    strings[0] = num
    for module = 1 to num
        do
            str = ""
            for i = 1 to stringsLen
                str .= abc[Random(0, UBound(abc) - 1, 1)]
        until Search(strings, str) = -1
        strings[module] = str
    return strings


;−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
func ProcessFiles()
;−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
    dim sourcePath, targetPath, isPlysFile
    dim text  ; storage for processing file data

    for module = 1 to DepTable[0][0]
        sourcePath = InputFileDir . "\" . DepTable[module][0]
        targetPath = PathPart(sourcePath, "drive", "ext") . ".au3"
        if RapidMode then
            if FileExists(targetPath) _
                    and GetTime(sourcePath, 0, 1) _
                        < GetTime(targetPath, 0, 1) then
                continueloop
                ; FIXME: name suffixes will be changed
                ; TODO: generate stable suffixes – with /Rapid option
        elseif RunMode then
            Add(PathsToDeleteOnExit, targetPath)
        isPlysFile = (PathPart(sourcePath, "ext") = ".aup")
        text = Read(sourcePath)

        if isPlysFile then        
            if LambdaFunctions then _ProcessLambdas(text, module)
            if CloseBlockByIndent then _CloseBlocks(text)
            if NoDollarPrefix then _AddVarPrefixes(text, DepTable[0][module])
            _RemoveAsterisks(text)
            if ConstByDefault then _ToggleDimConst(text)
        if ImportKeyword then _ProcessImports(text, module, isPlysFile)
        if Synonyms and isPlysFile then
            _RenameSynonyms(text, module = 1)

        if IsArray(text) then text = _ArrayToString(text, "", -1, -1, "", 0, 0)
        FileDelete(targetPath)
        Write(targetPath, text)
        if RunMode then
            SetAttrib(targetPath, "+H")
        else
            Echo('[Writed] "' . targetPath . '"' . @)
    next module


func _ProcessLambdas(dim byref text, module)
    text = __SplitStatements(text)
    dim n = 0, lambdas = ""
    dim name, args, expr
    dim names[UBound(text)]
    for i = 0 to UBound(text) - 1
        if text[i][1] <> LambdaType then continueloop
        do
            name = "_"
            for j = 1 to LambdaNameLen
                name .= ABC[Random(0, UBound(ABC) - 1, 1)]
        until Search(names, name) = -1
        names[n] = name
        n += 1
        args = ReFind(text[i][0], "(?:\{)([^:]*)", @ReArray)[0]
        expr = ReFind(text[i][0], "(?::)([^\}]+)", @ReArray)[0]
        text[i][0] = name
        text[i][1] = MainType
        lambdas .= @ _
            . "func " . name . "(" . args . ")" . @ _
                . TabInSpaces . "return " . expr . @ _
            . "endfunc" . @
    redim names[n]
    Add(DepTable[0][module], names)
    text = _ArrayToString(text, "", -1, -1, "", 0, 0) . lambdas


;=============================================================================
func _CloseBlocks(dim byref text)
;=============================================================================
    if IsArray(text) then text = _ArrayToString(text, "", -1, -1, "", 0, 0)
    text = ReReplace(text, "(?m:^|\G)\t", TabInSpaces)
    text = Split(text . @ . "end.", @, @EntireSplit + @NoCount)

    dim i = -1, j
    dim comments = False
    dim indentSize, prevIndentSize = 0
    dim statement, sttmnt
    dim split_
    dim closer, indent
    dim stack[0]
    while i + 1 <= UBound(text) - 1
        i += 1
        
        ; skip comments and directives (and empty lines)
        if ReFind(text[i], "^\s*($|;)") then continueloop
        if comments then
            if ReFind(text[i], "(?i)^\s*(\#ce|\#comments-end)") then
                comments = False
            continueloop
        if ReFind(text[i], "(?i)^\s*(\#cs|\#comments-start)") then
            comments = True
            continueloop
        ; if ReFind(text[i], "^\s*\#") then continueloop
        
        if RunMode and not ReFind(text[i], "^\s*$") then
            text[i] .= @tab . @tab . "; #" . (i + 1)
        
        indentSize = Len(ReReplace(text[i], "^( *).*", "$1"))
        statement = ReReplace(text[i], "^ *(\w*).*", "$1")
        if ReFind(statement, "(?i)^(else)?if$") then
            j = i
            while True
                split_ = __SplitStatements(text[j])
                if __ReFindInMain(split_, "(?i)\sthen(\s|$)") then  ; with then
                    exitloop
                j += 1
            if __ReFindInMain(split_, "(?i)\sthen\h.*?\S") then  ; then expr.
                statement = ""
        if indentSize < prevIndentSize then
            sttmnt = statement
            for is = indentSize to prevIndentSize - 1
                if is > UBound(stack) - 1 then exitloop
                switch stack[is]
                    case "if"
                        if ReFind(sttmnt, "(?i)^else(if)?$") then
                            sttmnt = ""
                            continueloop
                        closer = "endif"
                    case "elseif"
                        if ReFind(sttmnt, "(?i)^else(if)?$") then continueloop
                        closer = "endif"
                    case "else"
                        closer = "endif"
                    case "select", "switch", "with", "func"
                        closer = "end" . stack[is]
                    case "for"
                        closer = "next"
                    case "while"
                        closer = "wend"
                    case else
                        continueloop
                endswitch
                indent = ""
                for k = 1 to is
                    indent .= " "
                if ReFind(text[i], "^" . indent . closer . "\b") then
                    ; FIXME: must be replace even if disabled closeBlock
                    text[i] = Replace(text[i], closer, closer . ";")
                else
                    text[i] = indent . closer . @ . text[i]
            next is
            redim stack[indentSize]
        endif
        switch statement
            case "if", "elseif"
                i = j
                continuecase
            case "else", "select", "switch", "for", "while", "with", "func"
                redim stack[indentSize + 1]
                stack[indentSize] = statement
        prevIndentSize = indentSize
    wend
    text = _ArrayToString(text, @)
    text = ReReplace(text, "(?m)^end\.\s*(;.*)?$", "")


func _AddVarPrefixes(dim byref text, dim names)
    text = __SplitStatements(text)
    if IsArray(names) then
        names = _ArrayToString(names)
        names = ReReplace(names, "\|\$\w+\*?", "")  ; funcs only
        names = ReReplace(names, "\$\w+\*?\|", "")  ; funcs only
        if names <> "" then names = "|" . names
    else
        names = ""
    ; FIXME: call function, stored in variable: $foo($bar, $buz)
    __ReReplaceInMain(text, "(?i)" _
        . "(?(?=" _  ; if look ahead one of this
            . "\b(_|and|byref|case|const|continuecase|continueloop|default|" _
            . "dim|do|else|elseif|endfunc|endif|endselect|endswitch|endwith|" _
            . "enum|exit|exitloop|false|for|func|global|if|in|local|next|" _
            . "not|null|or|redim|return|select|static|step|switch|then|to|" _
            . "true|until|volatile|wend|while|with" . names . ")\b" _
        . ")" _  ; then replace
            . " " _
        . "|" _  ; else it’s variable: replace
            . "(?<![\w@$])" _  ; ← previous isn’t [\w@$]
            . "[A-Za-z_]\w*" _  ; ↓ next isn’t call, scope (or continuation)
            . "(?!\w*(\s*\(|:[A-Za-z_]))" _  ;|\s*_\W))" _
        . ")", _
        "\$$0")  ; by this


func _RemoveAsterisks(dim byref text)
    dim varsDeclars
    if IsArray(text) then _
        text = _ArrayToString(text, "", -1, -1, "", 0, 0)
    text = ReReplace(text, "(?im)^(\s*func\s+)([A-Za-z_]\w*)" _
        . ModulePublicSuffixRegEx, "$1$2")
    if ConstByDefault then
        varsDeclars = ReFind(text, _
            "(?im)^(?:\s*global\s+)?(?:dim|const|enum)\s+(.*)", _
            @ReArrayGlobal)
    else
        varsDeclars = ReFind(text, "(?im)^\s*global\s+(.*)", @ReArrayGlobal)
    if IsArray(varsDeclars) then
        ; FIXME: "const $bar = foo(1, 2)" → ["$bar = foo(1", " 2)"]
        dim newVarsDeclar, publicNames
        for varsDeclar in varsDeclars
            newVarsDeclar = varsDeclar
            for varDeclar in Split(varsDeclar, ",", @NoCount)
                publicNames = ReFind(varDeclar, _
                    "(\$\w+" . ModulePublicSuffixRegEx . ")", _
                    @ReArrayGlobal)
                if IsArray(publicNames) then
                    ; Display(publicNames)
                    newVarsDeclar = ReReplace(newVarsDeclar, _
                        "\" . TrimRight(publicNames[0], 1) _
                        . ModulePublicSuffixRegEx, _
                        "\" . TrimRight(publicNames[0], 1))
            if newVarsDeclar <> varsDeclar then _
                text = Replace(text, varsDeclar, newVarsDeclar)


func _ToggleDimConst(dim byref text)
    if IsArray(text) then _
        text = _ArrayToString(text, "", -1, -1, "", 0, 0)
    text = ReReplace(text, _
        "(?im)^(const|enum|static)\s+\$", "global $0")
    text = ReReplace(text, _
        "(?im)^(\s+)((?:const|enum|static)\s+\$)", "$1local $2")
    text = ReReplace(text, _
        "(?im)^dim(\s+\$)", "global$1")
    text = ReReplace(text, _
        "(?im)^(\s+)dim(\s+\$)", "$1local$2")
    dim funcDeclars = ReFind(text, "(?im)^\s*func\s+.*$", @ReArrayGlobal)
    if IsArray(funcDeclars) then
        dim newFuncDeclar, args
        for funcDeclar in funcDeclars
            newFuncDeclar = funcDeclar
            args = ReReplace(funcDeclar, _
                "(?i)\s*func\s+.*?\(\s*(.*)\s*\).*", "$1")
            if args = "" then continueloop
            args = Split(args, ",", @NoCount)
            for arg in args  ; insert “const”
                if not ReFind(arg, "\b(const|dim)\b") then
                    newFuncDeclar = _
                        Replace(newFuncDeclar, arg, " const " . arg)
            newFuncDeclar = _
                ReReplace(newFuncDeclar, "\bdim\s+", "")  ; delete “dim”
            text = Replace(text, funcDeclar, newFuncDeclar)


func _ProcessImports(dim byref text, module, isPlysFile)
    if IsArray(text) then text = _ArrayToString(text, "", -1, -1, "", 0, 0)
    if isPlysFile then __PreventReimporting(text, module)
            
    ; replace “#include/#import "path\name.ext"”
    ; with “#include "path\%target_prefix%name.ext.au3"”
    text = ReReplace(text, _
        '(?m)^\#(include' . (isPlysFile? "|import" : "") _
        . ')\s+"(.*\\)?(.*?)"(.*)$', _
        '#include "$2$3\.au3"$4')
    
    text = __SplitStatements(text)
    if DepTable[0][0] > 1 then __ReplaceOwnNames(text, module)
    __ReplaceNotOwnNames(text, module)


func __PreventReimporting(dim byref text, module)
; comment #import if module including or importing alredy been
    dim rel_dirSlash, relrel_dep, foundInPrev
    for dep = 1 to DepTable[0][0]
        if DepTable[module][dep] <> ImportDep then continueloop
        rel_dirSlash = PathPart(DepTable[module][0], "dir")
        relrel_dep = DepTable[dep][0]
        if rel_dirSlash <> "" then
            relrel_dep = Replace(relrel_dep, rel_dirSlash, "")
        relrel_dep = ReReplace(relrel_dep, "[\\\.\^\$\[\(\{\+\#]", "\\$0")
        text = ReReplace(text, _
            '(?m)^\#(include|import)\s+[<"]' . relrel_dep . '[>"]', ";PLYS $0")
        foundInPrev = False
        for prev = 1 to module - 1
            if DepTable[prev][dep] then
                foundInPrev = True
                exitloop
        if not foundInPrev then  ; uncomment first
            text = ReReplace(text, '(?m)^;PLYS (\#(include|import)\s+[<"]' _
                . relrel_dep . '[>"])', "$1", 1)


func __ReplaceOwnNames(dim byref text, module)
    const names = DepTable[0][module]
    if not IsArray(names) then return
    ; purified filename
    dim prefix = PathPart(DepTable[module][0], "dir", "name")
    prefix = ReReplace(prefix, "\W", "_")
    ; TODO: загнать имена в шаблон (имя|имя|…) и заменить одним махом
    for name in names
        if Left(name, 1) = "$" then  ; is variable
            __ReReplaceInMain(text, _
                "(?im)([^\w""'" . NameDelimRegEx . "]|^)\$(" _
                    . TrimLeft(name, 1) . ")([^\w""'])", _
                "$1\$" . prefix . "_$2$3")
        else  ; is function
            prefix = ReReplace(prefix, "^[0-9]", "_$1")
            __ReReplaceInMain(text, _
                "(?im)([^\w""'\$" . NameDelimRegEx . "]|^)(" . name _
                . ")([^\w""'])", _
                "${1}" . prefix . "_$2$3")


;−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
func __ReplaceNotOwnNames(dim byref text, module)
; replace names from ThruTable[0][dep] in module file
;−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
    const depTypes = [ImportDep, IncludeDep, MirIncludeDep]
    dim names
    dim filename, prefix, varPrefix, isPublic
    for depType in depTypes
        for dep = 1 to DepTable[0][0]
            if ThruTable[module][dep] <> depType then continueloop
            names = DepTable[0][dep]
            if IsArray(names) then
                ; purified filename
                filename = PathPart(DepTable[dep][0], "name")
                filename = ReReplace(filename, "[^\w]", "_")
                prefix = PathPart(DepTable[dep][0], "dir")
                prefix = ReReplace(prefix, "[^\w]", "_")
                prefix .= filename
                for name in names
                    if Left(name, 1) = "$" then  ; is variable
                        name = TrimLeft(name, 1)
                        varPrefix = "\$"
                    else
                        prefix = ReReplace(prefix, "^[0-9]", "_$1")
                        varPrefix = ""
                    if ReFind(name, ModulePublicSuffixRegEx . "$") then
                        name = TrimRight(name, 1)
                        isPublic = True
                    else
                        isPublic = False
                    if ThruTable[module][dep] <> ImportDep then
                        __ReReplaceInMain(text, _
                            "(?im)([^\w""']|^)" . varPrefix . name _
                            . "([^\w""'])", _
                            "${1}" . varPrefix . prefix . "_" . name _
                            . "$2")
                    elseif isPublic then  ; ImportDep and isPublic
                        __ReReplaceInMain(text, _
                            "(?im)([^\w""']|^)" . filename _
                            . NameDelimRegEx . varPrefix . name _
                            . "([^\w""'])", "${1}" . varPrefix . prefix _
                            . "_" . name . "$2")


;=============================================================================
func _RenameSynonyms(dim byref text, isMainModule)
;=============================================================================
        if IsString(text) then text = __SplitStatements(text)
        ;
        __ReReplaceInMain(text, "(?i)\bEcho\b", "ConsoleWrite")
        ; DllStruct −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
        __ReReplaceInMain(text, "(?i)\bStruct\b", "DllStructCreate")
        __ReReplaceInMain(text, "(?i)\bStructGet\b", "DllStructGetData")
        __ReReplaceInMain(text, "(?i)\bStructGetSize\b", "DllStructGetSize")
        __ReReplaceInMain(text, "(?i)\bStructGetPtr\b", "DllStructGetPtr")
        __ReReplaceInMain(text, "(?i)\bStructSet\b", "DllStructSetData")
        __ReReplaceInMain(text, "(?i)\bIsStruct\b", "IsDllStruct")
        ; File −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
        __ReReplaceInMain(text, "(?i)\b(" _
            . "ChangeDir|Copy|CreateShortcut|Flush|GetAttrib|GetEncoding|" _
            . "GetLongName|GetShortcut|GetShortName|GetSize|GetTime|" _
            . "GetVersion|Open|OpenDialog|Read|ReadLine|ReadToArray|Recycle|" _
            . "RecycleEmpty|SaveDialog|SelectFolder|SetAttrib|SetEnd|SetPos|" _
            . "SetTime|Write|WriteLine" _
            . ")\b", "File$1")
        __ReReplaceInMain(text, "(?i)\bCreateLink\b", "FileCreateNTFSLink")
        __ReReplaceInMain(text, "(?i)\bFirstFile\b", "FileFindFirstFile")
        __ReReplaceInMain(text, "(?i)\bNextFile\b", "FileFindNextFile")
        ; **Close|**Delete|**Exists|**GetPos|Install|**Move
        ; String −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
        __ReReplaceInMain(text, "(?i)\b(" _
            . "AddCR|Format|InStr|IsAlNum|IsAlpha|IsASCII|IsDigit|IsLower|" _
            . "IsSpace|IsUpper|IsXDigit|Left|Len|Lower|Mid|Replace|Right|" _
            . "Split|StripCR|StripWS|TrimLeft|TrimRight|Upper" _
            . ")\b", "String$1")
        __ReReplaceInMain(text, "(?i)\bReFind\b", "StringRegExp")
        __ReReplaceInMain(text, "(?i)\bReReplace\b", "StringRegExpReplace")
        ; Compare|FromASCIIArray|*IsFloat|*IsInt|**Reverse|ToASCIIArray
        ; Win −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
        __ReReplaceInMain(text, "(?i)\b(" _
            . "Activate|Active|Flash|GetCaretPos|GetClassList|GetClientSize|" _
            . "GetProcess|GetTitle|Kill|List|MenuSelectItem|MinimizeAll|" _
            . "MinimizeAllUndo|SetOnTop|SetTitle|SetTrans|Wait|WaitActive|" _
            . "WaitClose|WaitNotActive" _
            . ")\b", "Win$1")
        ; **Close|**Exists|*GetHandle|**GetPos|*GetState|*GetText|**Move
        ; |*SetState
        ; Macros −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
        __ReReplaceInMain(text, "(?i)(@)(" _
            . "NoCaseSense|CaseSense|NoCaseSenseBasic|StripLeading|" _
            . "StripTrailing|StripSpaces|StripAll|ChrSplit|EntireSplit|" _
            . "NoCount|EndNotStart|UTF16|UCS2" _
            . ")\b", "$Str_$2")
        __ReReplaceInMain(text, "(?i)(@Re)(" _
            . "Array|ArrayFull|ArrayGlobal|ArrayGlobalFull" _
            . ")\b", "$Str_RegExp$2Match")
        __ReReplaceInMain(text, "(?i)@ReMatch\b", "$STR_REGEXPMATCH")
        __ReReplaceInMain(text, "(?i)@ActiveWin\b", 'WinGetHandle("[ACTIVE]")')
        __ReReplaceInMain(text, "(?i)@CmdLine\b", "$CmdLine")
        __ReReplaceInMain(text, "@(\W)", "@CRLF$1")
        ; _Array −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
        __ReReplaceInMain(text, "(?i)\b(" _
            . "Add|ColDelete|ColInsert|Combinations|Display|Extract|FindAll|" _
            . "Insert|Max|MaxIndex|Min|MinIndex|Permute|Pop|Push|Search|" _
            . "Shuffle|Sort|Swap|ToClip|Transpose|Trim|Unique" _
            . ")\b", "_Array$1")
        ; __ReReplaceInMain(text, "(?i)\b(Filter|Map|Reduce)\b", "_Array$1")
        __ReReplaceInMain(text, "(?i)\bToHistogram\b", "_Array1DToHistogram")
        __ReReplaceInMain(text, "(?i)\bBinSearch\b", "_ArrayBinarySearch")
        __ReReplaceInMain(text, "(?i)\bConcat\b", "_ArrayConcatenate")
        ; **Delete|**Reverse|*ToString
        ; −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
        __ReReplaceInMain(text, "(\s)\.(\s)", "$1&$2")
        __ReReplaceInMain(text, "\.=", "&=")
        if isMainModule then
            text = _ArrayToString(text, "", -1, -1, "", 0, 0)
            text = ReReplace(text, "(?im)^(?!#au)", _
                "#include <StringConstants.au3>" . @ _
                . "#include <Array.au3>" . @, 1); _
                ; . "#include <Function.au3>" . @, 1)


func ProcessStdio(pid)
    const proc = _WinAPI_OpenProcess( _
        (_WinAPI_GetVersion() >= 6.0)? _
            PROCESS_QUERY_LIMITED_INFORMATION _
            : PROCESS_QUERY_INFORMATION, 0, pid)
    const lastData = _WaitClose(pid)
    StdioClose(pid)
    if _WinAPI_GetExitCodeProcess(proc) = 0 then
        if not RapidMode then
            for path in PathsToDeleteOnExit
                FileDelete(path)
    elseif ErrorStdOut and lastData <> "" then
        ConsoleWrite(_FormatError(lastData))
    _WinAPI_CloseHandle(proc)


func _WaitClose(pid)
    dim timer = TimerInit()
    dim stdoutData, lastData = "", lastLoop = False
    while True
        StdinWrite(pid, ConsoleRead())
        ConsoleWriteError(StderrRead(pid))
        if ErrorStdOut then
            stdoutData = StdoutRead(pid)
            if stdoutData <> "" then lastData = stdoutData
            ConsoleWrite(stdoutData)
        else
            ConsoleWrite(StdoutRead(pid))
        if lastLoop then exitloop
        if TimerDiff(timer) > 300 then
            if not ProcessExists(pid) then lastLoop = True
            timer = TimerInit()
        GUIGetMsg()  ; prevents hogging of the CPU
    return lastData


func _FormatError(dim errorData)
    ; TODO: catch more than one error in message
    errorData = ReFind(errorData, _
        '[^"]*("?)([a-zA-Z]:\\.+?\\.+?\.au[p3])(\.au3)("? \()(\d+)' _
        . '(\) : ==> )(.+?)\.: ?\R(.+\R)([^^]*)(\^ ERROR\R)$', _
        @ReArray)
    const line = ReadLine(errorData[1] . errorData[2], errorData[4])
    errorData[2] = ""
    errorData[4] = ReReplace(line, ".*?\t\t; #(\d+)$", "$1")
    errorData[6] .= ": " . TrimLeft(errorData[7], Len(errorData[8]))
    return _ArrayToString(errorData, "", 0, 6)


;−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
func GetDeps(dim byref DepTable, rel_path)
; Search all #include and #import paths in rel_path file, add module numbers
; into DepTable and recursively process this dependencies.
; rel_* - relative to InputFileDir, relrel_* - relative to rel_path
;−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
    dim text = Read(InputFileDir . "\" . rel_path)

    ; append and init new module cells
    const module = DepTable[0][0] + 1
    redim DepTable[module + 1][module + 1]
    DepTable[0][0] = module
    DepTable[module][0] = rel_path
    DepTable[0][module] = _FindNames(text)
    
    const relrel_includes = _
        ReFind(text, '(?m)^\#include\s+"(.+?)"', @ReArrayGlobal)
    const importEnabled = _
        ImportKeyword and PathPart(rel_path, "ext") = ".aup"
    if importEnabled then
        const relrel_imports = _
            ReFind(text, '(?m)^\#import\s+"(.+?)"', @ReArrayGlobal)
    text = ""
    const depTypes = [IncludeDep, ImportDep]
    dim relrel_deps, rel_dep, dep
    const rel_dirSlash = PathPart(rel_path, "dir")  ; current_file\directory\
    for depType in depTypes
        if depType = IncludeDep then
            relrel_deps = relrel_includes
        elseif importEnabled then
            relrel_deps = relrel_imports
        else
            continueloop
        if not IsArray(relrel_deps) then continueloop
        
        for relrel_dep in relrel_deps
            rel_dep = rel_dirSlash . relrel_dep
            dep = Search(DepTable, rel_dep, 1, default, _
                default, default, default, 0)  ; from 1 element in col 0
            if dep = -1 then  ; new path
                GetDeps(DepTable, rel_dep)
                dep = Search(DepTable, rel_dep, 1, default, _
                    default, default, default, 0)  ; from 1 element in col 0
            DepTable[module][dep] = depType
        
    next depType


func _FindNames(byref text)
    dim names = ReFind(text, _
        "(?im)^\s*func\s+([A-Za-z_]\w*" . ModulePublicSuffixRegEx . "?)", _
        @ReArrayGlobal)
    if not IsArray(names) then _
        dim names[0]
    dim varsDeclars
    if ConstByDefault then
        varsDeclars = ReFind(text, _
            "(?im)^(?:\s*global\s+)?(?:dim|const|enum)\s+(.*)", _
                @ReArrayGlobal)
    else
        varsDeclars = ReFind(text, "(?im)^\s*global\s+(.*)", @ReArrayGlobal)
    if IsArray(varsDeclars) then
        ; FIXME: "const $bar = foo(1, 2)" → ["$bar = foo(1", " 2)"]
        dim newNames
        for varsDeclar in varsDeclars
            for varDeclar in Split(varsDeclar, ",", @NoCount)
                ;newNames = ReFind _
                ;    (varDeclar, "(\$\w*)", @ReArrayGlobal)
                ;if IsArray(newNames) then Add(names, newNames[0])
                newNames = ReFind(varDeclar, _
                    "([\$A-Za-z_]\w*" . ModulePublicSuffixRegEx . "?)", _
                    @ReArrayGlobal)
                if IsArray(newNames) then
                    Add(names, ReReplace(newNames[0], "^\w", "\$$0", 1))
    return Unique(names, 0, 0, 0, ARRAYUNIQUE_NOCOUNT)


func PathPart(path, dim start="path", dim finish="")
; Select subpath from start to finish part
; if start="path" then returns original path
; if finish="" then returns start only
    const components = ["path", "drive", "dir", "name", "ext"]
    start = Search(components, start)
    if @error then start = 0
    finish = Search(components, finish)
    if @error then finish = start
    
    ; from _PathSplit (File.au3)
    dim split_ = ReFind(path, _
        "^\h*((?:\\\\\?\\)*(\\\\[^\?\/\\]+|[A-Za-z]:)?(.*[\/\\]\h*)?" _
        . "((?:[^\.\/\\]|(?(?=\.[^\/\\]*\.)\.))*)?([^\/\\]*))$", @ReArray)
    if @error then ; This error should never happen.
        redim split_[5]
        split_[0] = path
    split_[2] = ReReplace(split_[2], "\h*[\/\\]+\h*", _
        (Left(split_[2], 1) == "/")? "\/" : "\\")
    
    dim result = ""
    for i = start to finish
        result .= split_[i]
    return result


;−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
func __SplitStatements(byref text)
;−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
    dim split_[1][2], i = 0
    dim result
    dim patterns[5], type = MainType
    patterns[CommentType] = _
        "(?is)(;|\#cs.*?\#ce|\#comments-start.*?\#comments-end).*?(\R|\z)"
    patterns[DirectiveType] = "\#.*"
    patterns[StringType] = "((""|').*?\2)"
    patterns[LambdaType] = "(\{.*?:.*?\})"
    patterns[MainType] = _
        "(?s).*?(?=[;""'\#" . (LambdaFunctions? "\{" : "") . "]|\z)"
    dim offset = 1
    const len_ = Len(text)
    while True
        ;redim split_[i + 1][2]  ; optimized below
        if i > UBound(split_) - 1 then redim split_[UBound(split_)*2][2]
        result = ReFind(text, patterns[type], @ReArrayFull, offset)[0]
        if @error then exitloop
        split_[i][0] = result
        split_[i][1] = type
        offset = @extended
        if offset > len_ then exitloop
        switch Mid(text, offset, 1)
            case ";"
                type = CommentType
            case "#"
                type = (ReFind(text, "(?i)(\#cs|\#comments-start)", _
                    @ReMatch, offset))? CommentType : DirectiveType
                type = (Mid(text, offset, 3) = "#cs" _
                    or Mid(text, offset, 15) = "#comments-start")? _
                    CommentType : DirectiveType
            case """", "'"
                type = StringType
            case "{"
                type = LambdaType
            case else
                type = MainType
        i += 1
    wend
    return split_


func __ReFindInMain(byref split_, pattern, flag=0)
    dim match, result[0]
    for i = 0 to UBound(split_) - 1
        if split_[i][1] <> MainType then continueloop
        switch flag
            case @ReMatch
                if ReFind(split_[i][0], pattern, flag) then return 1
                if @error then return SetError(@error, @extended)
            case @ReArrayGlobal
                match = ReFind(split_[i][0], pattern, flag)
                switch @error
                    case 2
                        return SetError(@error, @extended)
                    case 0
                        Concat(result, match)
    switch flag
        case @ReMatch
            return 0
        case @ReArrayGlobal
            return (UBound(result) = 0)? SetError(1) : result


func __ReReplaceInMain(dim byref split_, pattern, replace_, count=0)
    dim performed = 0, remainder = count
    for i = 0 to UBound(split_) - 1
        if split_[i][1] <> MainType then continueloop
        split_[i][0] = ReReplace(split_[i][0], pattern, replace_, remainder)
        if @error then return SetError(@error, @extended)
        performed += @extended
        if count <> 0 then
            remainder -= @extended
            if remainder = 0 then exitloop
    return performed


; ATTENTION: not used
func __ReplaceInMain(dim byref split_, subString, replaceString)
    dim performed = 0
    for i = 0 to UBound(split_) - 1
        if split_[i][1] <> MainType then continueloop
        split_[i][0] = Replace(split_[i][0], subString, replaceString)
        if @error then return SetError(@error, 0, "")
        performed += @extended
    return performed
