#include <ProcessConstants.au3>
#include <TrayConstants.au3>
#include <WinAPIHObj.au3>
#include <WinAPIProc.au3>
#include <WinAPISys.au3>
Opt("MustDeclareVars", 1)

; NOTE: rel_* - relative to InputFileDir, relrel_* - relative to rel_path

enum IncludeDep = 2, MirIncludeDep = 1.5, ImportDep = 1

; Translation settings
const MainTokenDelim = Chr(0x0C)  ; form feed
const LambdaNameLen = 36
const TabInSpaces = "    "
const PublicSuffixRegEx = "\*"
const NewSuffixLen = 2
const NameDelimRegEx = ":"

; Default project settings
dim StdioExchange = True
dim LambdaFunctions = False
dim NoDollarPrefix = True
dim ConstByDefault = True
dim CloseBlockByIndent = True
dim ImportKeyword = True
dim Synonyms = True

; Translator options
dim RunMode = True
dim ErrorStdOut = False
dim RapidMode = False
dim InputFilePath
dim InputFileDir

; Table of dependencies
;    Array size: DepTable[n+1][n+1]
;    Array structure:
;       DepTable[0][0] = n                number of files
;       DepTable[1..n][0]                  relative path to file “n”
;       DepTable[0][1..n]                  names array of file “n”
;       DepTable[i][j] = include        file “i” includes file “j”
dim DepTable[1][1] = [[0]]

; Table of visibilities: which module sees names from which module
; (based on DepTable)
dim ThruTable

dim PathsToDeleteOnExit[0]


Main()


func Main*()
    const scriptArgs = ProcessCmdLine()
    GetProjectSettings()

    TraySetIcon("stop")
    TraySetState(TRAY_ICONSTATE_FLASH)

    const rel_path = PathPart(InputFilePath, "name", "ext")
    GetDeps(DepTable, rel_path)
    if not RunMode then Echo("[Dependencies are get]" . @)

    if ImportKeyword then MakeThruTable()

    ProcessFiles()

    DepTable = 0
    if ImportKeyword then ThruTable = 0

    if RunMode then
        const pid = Run('"' . @AutoItExe _
                . (ErrorStdOut? '" /ErrorStdOut "' : '" "') . InputFilePath _
                . '.au3" ' . scriptArgs, "", default, _
                STDIN_CHILD + STDERR_CHILD + STDOUT_CHILD)
        if StdioExchange then
            Opt("TrayIconHide", 1)
            ProcessStdio(pid)


func ProcessCmdLine()
; @CmdLine = [0:n, 1:path, 2:args] or [0:n, 1:/ErrorStdOut, 2:path, 3:args]
    const pathIndex = _GetPathIndex()
    if pathIndex = 0 then
        InputFilePath = OpenDialog("Run Script:", @MyDocumentsDir, _
                "Plys script files (*.aup)|All files (*.*)")
        ; TODO: AutoIt script files (*.au3;*.a3x)
        if @error then exit
    else
        InputFilePath = @CmdLine[pathIndex]

    InputFileDir = PathPart(InputFilePath, "drive", "dir")

    const argc = @CmdLine[0] - pathIndex
    if argc = 0 then return ""
    dim argv[argc]
    for i = pathIndex + 1 to @CmdLine[0]
        argv[i - 2] = '"' . @CmdLine[i] . '"'
    return _ArrayToString(argv, " ")


func _GetPathIndex()
    if @CmdLine[0] = 0 then return 0
    for i = 1 to @CmdLine[0]
        if Left(@CmdLine[i], 1) <> "/" then exitloop
        switch @CmdLine[i]
            case "/Translate"
                RunMode = False
            case "/ErrorStdOut"
                ErrorStdOut = True
            case "/Rapid"
                RapidMode = True
    return i


func GetProjectSettings()
    const text = Read(InputFilePath)
    StdioExchange = StdioExchange _
            and not ReFind(text, "(?m)^\#plys nostdio")
    LambdaFunctions = LambdaFunctions _
            or ReFind(text, "(?m)^\#plys lambda")
    NoDollarPrefix = NoDollarPrefix _
            and not ReFind(text, "(?m)^\#plys dollarprefix")
    ConstByDefault = ConstByDefault _
            and not ReFind(text, "(?m)^\#plys noconst")
    CloseBlockByIndent = CloseBlockByIndent _
            and not ReFind(text, "(?m)^\#plys noindent")
    ImportKeyword = ImportKeyword _
            and not ReFind(text, "(?m)^\#plys noimport")
    Synonyms = Synonyms _
            and not ReFind(text, "(?m)^\#plys nosynonyms")


;··············································································
func GetDeps(dim byref DepTable, rel_path)
; Search all #include and #import paths in rel_path file, add module numbers
; into DepTable and recursively process this dependencies.
;··············································································
    dim text = Read(InputFileDir . "\" . rel_path)

    ; append and init new module cells
    const module = DepTable[0][0] + 1
    redim DepTable[module + 1][module + 1]
    DepTable[0][0] = module
    DepTable[module][0] = rel_path
    DepTable[0][module] = _FindNames(text)
    
    const relrel_includes = _
            ReFind(text, '(?m)^\#include\s+"(.+?)"', @ReArrayGlobal)
    const importEnabled = _
            ImportKeyword and PathPart(rel_path, "ext") = ".aup"
    if importEnabled then
        const relrel_imports = _
                ReFind(text, '(?m)^\#import\s+"(.+?)"', @ReArrayGlobal)
    text = ""
    const depTypes = [IncludeDep, ImportDep]
    dim relrel_deps, rel_dep, dep
    const rel_dirSlash = PathPart(rel_path, "dir")  ; current_file\directory\
    for depType in depTypes
        if depType = IncludeDep then
            relrel_deps = relrel_includes
        elseif importEnabled then
            relrel_deps = relrel_imports
        else
            continueloop
        if not IsArray(relrel_deps) then continueloop
        
        for relrel_dep in relrel_deps
            rel_dep = rel_dirSlash . relrel_dep
            dep = Search(DepTable, rel_dep, 1, default, _
                    default, default, default, 0)  ; from 1 element in col 0
            if dep = -1 then  ; new path
                GetDeps(DepTable, rel_dep)
                dep = Search(DepTable, rel_dep, 1, default, _
                        default, default, default, 0)  ; from 1st elem in col 0
            DepTable[module][dep] = depType
        
    next depType


func _FindNames(byref text)
    dim names = ReFind(text, _
            "(?im)^\s*func\s+([A-Za-z_]\w*" . PublicSuffixRegEx . "?)", _
            @ReArrayGlobal)
    if not IsArray(names) then
        dim names[0]
    dim varsDeclars
    if ConstByDefault then
        varsDeclars = ReFind(text, _
                "(?im)^(?:\s*global\s+)?(?:dim|const|enum)\s+(.*)", _
                @ReArrayGlobal)
    else
        varsDeclars = ReFind(text, "(?im)^\s*global\s+(.*)", @ReArrayGlobal)
    if IsArray(varsDeclars) then
        ; FIXME: "const $bar = foo(1, 2)" → ["$bar = foo(1", " 2)"]
        dim newNames
        for varsDeclar in varsDeclars
            for varDeclar in Split(varsDeclar, ",", @NoCount)
                ;newNames = ReFind _
                ;       (varDeclar, "(\$\w*)", @ReArrayGlobal)
                ;if IsArray(newNames) then Add(names, newNames[0])
                newNames = ReFind(varDeclar, _
                        "([\$A-Za-z_]\w*" . PublicSuffixRegEx . "?)", _
                        @ReArrayGlobal)
                if IsArray(newNames) then
                    Add(names, ReReplace(newNames[0], "^\w", "\$$0", 1))
    return Unique(names, 0, 0, 0, ARRAYUNIQUE_NOCOUNT)


;··············································································
func MakeThruTable()
;··············································································
    ThruTable = DepTable
    
    ; capture dependencies throught
    dim changed
    do
        changed = False
        for row = 1 to ThruTable[0][0]
            for col = 1 to ThruTable[0][0]
                switch ThruTable[row][col]
                    case IncludeDep ; ———————————————
                        ; “mirror” rule
                        if ThruTable[col][row] <= ImportDep then
                            ThruTable[col][row] = MirIncludeDep
                            changed = True
                        ; “chain” rule for column
                        for y = 1 to ThruTable[0][0]
                            if y <> col _
                                    and ThruTable[y][row] > ThruTable[y][col] _
                            then
                                ThruTable[y][col] = ThruTable[y][row]
                                changed = True
                    case ImportDep ; ————————————————
                        ; “chain” rule for column
                        for y = 1 to ThruTable[0][0]
                            if y <> col _
                                    and ThruTable[y][row] > ImportDep _
                                    and ThruTable[y][col] = "" _
                            then
                                ThruTable[y][col] = ImportDep
                                changed = True
                endswitch
            next col
        next row
    until not changed


;··············································································
func ProcessFiles()
;··············································································
    dim sourcePath, targetPath, isPlysFile
    dim main, misc  ; storages for processing file data

    for module = 1 to DepTable[0][0]
        sourcePath = InputFileDir . "\" . DepTable[module][0]
        targetPath = PathPart(sourcePath, "drive", "ext") . ".au3"
        if RapidMode then
            if FileExists(targetPath) _
                    and GetTime(sourcePath, 0, 1) _
                            < GetTime(targetPath, 0, 1) then
                continueloop
        elseif RunMode then
            Add(PathsToDeleteOnExit, targetPath)
        isPlysFile = (PathPart(sourcePath, "ext") = ".aup")
        main = Read(sourcePath)
        misc = _SeparateMain(main)

        if isPlysFile then        
            if LambdaFunctions then
                Add(DepTable[0][module], _ProcessLambdas(main, misc))
            if CloseBlockByIndent then _CloseBlocks(main)
            if NoDollarPrefix then _AddVarPrefixes(main, DepTable[0][module])
            _RemoveAsterisks(main)
            if ConstByDefault then _ToggleDimConst(main)
        if ImportKeyword then _ProcessImports(main, module, isPlysFile)
        if Synonyms and isPlysFile then
            _RenameSynonyms(main, module = 1)

        _CombineTokens(main, misc)
        FileDelete(targetPath)
        Write(targetPath, main)
        if RunMode then
            SetAttrib(targetPath, "+H")
        else
            Echo('[Writed] "' . targetPath . '"' . @)
    next module


func _SeparateMain(dim byref txt)
    const miscPattern = "(?m)" _
        . "^\s*#cs(?s:.*?)#ce.*" _
        . "|^\s*#comments-start(?s:.*?)#comments-end.*" _
        . "|^\s*#.*" _
        . '|".*?[^"]"(?!")' _
        . "|'.*?[^']'(?!')" _
        . "|\s_\h*(?:;.*)?" _
        . "|;.*" _
        . "|{.*?}"
    const misc = ReFind(txt, miscPattern, @ReArrayGlobal)
    txt = ReReplace(txt, miscPattern, MainDelimiter)
    return misc


func _ProcessLambdas(dim byref main, dim byref misc)
    dim n = 0, lambdas = ""
    dim name, args, expr
    dim names[UBound(misc)]
    for i = 0 to UBound(misc) - 1
        if not ReFind(misc[i], "^{.*}$") then continueloop
        do
            name = ""
            for j = 1 to LambdaNameLen
                name .= Chr(Random(Asc("a"), Asc("z"), 1))
        until Search(names, name) = -1
        names[n] = name
        n += 1
        args = ReFind(misc[i], "(?:\{)([^:]*)", @ReArray)[0]
        expr = ReFind(misc[i], "(?::)([^\}]+)", @ReArray)[0]
        main = Split(main, MainDelimiter, @NoCount)
        main[i] .= name
        main = _ArrayToString(main, MainDelimiter)
        misc[i] = ""
        lambdas .= @ . @ _
                . "func " . name . "(" . args . ")" . @ _
                    . TabInSpaces . "return " . expr . @ _
                . "endfunc" . @
    main .= lambdas
    redim names[n]
    return names


;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
func _CloseBlocks(dim byref text)
;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    text = ReReplace(text, "(?m:^|\G)\t", TabInSpaces)
    text = Split(text . @ . "end.", @, @EntireSplit + @NoCount)

    dim i = -1
    dim comments = False
    dim indentSize, prevIndentSize = 0
    dim statement, sttmnt
    dim closer, indent
    dim stack[0]
    while i + 1 <= UBound(text) - 1
        i += 1
        
        ; skip comments and directives (and empty lines)
        if ReFind(text[i], "^\s*($|;)") then continueloop
        if comments then
            if ReFind(text[i], "(?i)^\s*(\#ce|\#comments-end)") then
                comments = False
            continueloop
        if ReFind(text[i], "(?i)^\s*(\#cs|\#comments-start)") then
            comments = True
            continueloop
        ; if ReFind(text[i], "^\s*\#") then continueloop
        
        if RunMode and not ReFind(text[i], "^\s*$") then
            text[i] .= @tab . @tab . "; #" . (i + 1)
        
        indentSize = Len(ReReplace(text[i], "^( *).*", "$1"))
        statement = ReReplace(text[i], "^ *(\w*).*", "$1")
        if ReFind(statement, "(?i)^(else)?if$") then
            for then_i = i to UBound(text) - 1
                if ReFind(text[then_i], "(?i)\bthen\b") then  ; with “then”
                    exitloop
            if ReFind(text[then_i], "(?i)\bthen\h.*?\S") then  ; with then expr
                statement = ""
        if indentSize < prevIndentSize then
            sttmnt = statement
            for is = indentSize to prevIndentSize - 1
                if is > UBound(stack) - 1 then exitloop
                switch stack[is]
                    case "if"
                        if ReFind(sttmnt, "(?i)^else(if)?$") then
                            sttmnt = ""
                            continueloop
                        closer = "endif"
                    case "elseif"
                        if ReFind(sttmnt, "(?i)^else(if)?$") then continueloop
                        closer = "endif"
                    case "else"
                        closer = "endif"
                    case "select", "switch", "with", "func"
                        closer = "end" . stack[is]
                    case "for"
                        closer = "next"
                    case "while"
                        closer = "wend"
                    case else
                        continueloop
                indent = ""
                for k = 1 to is
                    indent .= " "
                if ReFind(text[i], "^" . indent . closer . "\b") then
                    ; FIXME: must be replace even if disabled closeBlock
                    text[i] = ReReplace(text[i], closer, closer . ";", 1)
                else
                    text[i] = indent . closer . @ . text[i]
            next is
            redim stack[indentSize]
        endif
        switch statement
            case "if", "elseif"
                i = then_i
                continuecase
            case "else", "select", "switch", "for", "while", "with", "func"
                redim stack[indentSize + 1]
                stack[indentSize] = statement
        prevIndentSize = indentSize
    wend
    text = _ArrayToString(text, @)
    text = ReReplace(text, "\Rend\.\s*(;.*)?$", "")


func _AddVarPrefixes(dim byref text, dim names)
    if IsArray(names) then
        names = _ArrayToString(names)
        names = ReReplace(names, "\|\$\w+\*?", "")  ; funcs only
        names = ReReplace(names, "\$\w+\*?\|", "")  ; funcs only
        if names <> "" then names = "|" . names
    else
        names = ""
    ; FIXME: call function, stored in variable: $foo($bar, $buz)
    ReReplace(text, "(?i)" _
            . "(?(?=" _  ; if look ahead one of this
            . "\b(_|and|byref|case|const|continuecase|continueloop|default|" _
            . "dim|do|else|elseif|endfunc|endif|endselect|endswitch|endwith|" _
            . "enum|exit|exitloop|false|for|func|global|if|in|local|next|" _
            . "not|null|or|redim|return|select|static|step|switch|then|to|" _
            . "true|until|volatile|wend|while|with" . names . ")\b" _
            . ")" _  ; then replace
            . " " _
            . "|" _  ; else it’s variable: replace
            . "(?<![\w@$])" _  ; ← previous isn’t [\w@$]
            . "[A-Za-z_]\w*" _  ; ↓ next isn’t call, scope (or continuation)
            . "(?!\w*(\s*\(|:[A-Za-z_]))" _  ;|\s*_\W))" _
            . ")", _
            "\$$0")  ; by this


func _RemoveAsterisks(dim byref text)
    text = ReReplace(text, "(?im)^(\s*func\s+)([A-Za-z_]\w*)" _
            . PublicSuffixRegEx, "$1$2")
    const varsDeclars = ReFind(text, "(?im)^" _
            . (ConstByDefault? _
                    "(?:\s*global\s+)?(?:dim|const|enum)" _
                    : "\s*global")
            . "\s+(.*)", @ReArrayGlobal)
    if not IsArray(varsDeclars) then return
    ; FIXME: "const $bar = foo(1, 2)" → ["$bar = foo(1", " 2)"]
    dim newVarsDeclar, publicNames
    for varsDeclar in varsDeclars
        newVarsDeclar = varsDeclar
        for varDeclar in Split(varsDeclar, ",", @NoCount)
            publicNames = ReFind(varDeclar, _
                    "(\$\w+" . PublicSuffixRegEx . ")", _
                    @ReArrayGlobal)
            if not IsArray(publicNames) then continueloop
            newVarsDeclar = ReReplace(newVarsDeclar, _
                    "(\" . TrimRight(publicNames[0], 1) . ")" _
                    . PublicSuffixRegEx, "\1", 1)
        if newVarsDeclar <> varsDeclar then
            text = Replace(text, varsDeclar, newVarsDeclar)


func _ToggleDimConst(dim byref text)
    text = ReReplace(text, _
            "(?im)^(const|enum|static)\s+\$", "global $0")
    text = ReReplace(text, _
            "(?im)^(\s+)((?:const|enum|static)\s+\$)", "$1local $2")
    text = ReReplace(text, _
            "(?im)^dim(\s+\$)", "global$1")
    text = ReReplace(text, _
            "(?im)^(\s+)dim(\s+\$)", "$1local$2")
    dim funcDeclars = ReFind(text, "(?im)^\s*func\s+.*$", @ReArrayGlobal)
    if IsArray(funcDeclars) then
        dim newFuncDeclar, args
        for funcDeclar in funcDeclars
            newFuncDeclar = funcDeclar
            args = ReReplace(funcDeclar, _
                    "(?i)\s*func\s+.*?\(\s*(.*)\s*\).*", "$1")
            if args = "" then continueloop
            args = Split(args, ",", @NoCount)
            for arg in args  ; insert “const”
                if not ReFind(arg, "\b(const|dim)\b") then
                    newFuncDeclar = _
                            Replace(newFuncDeclar, arg, " const " . arg)
            newFuncDeclar = _
                    ReReplace(newFuncDeclar, "\bdim\s+", "")  ; delete “dim”
            text = Replace(text, funcDeclar, newFuncDeclar)


func _ProcessImports(dim byref text, module, isPlysFile)
    if isPlysFile then __PreventReimporting(text, module)
            
    ; replace “#include/#import "path\name.ext"”
    ; with “#include "path\%target_prefix%name.ext.au3"”
    text = ReReplace(text, _
            '(?m)^\#(include' . (isPlysFile? "|import" : "") _
            . ')\s+"(.*\\)?(.*?)"(.*)$', _
            '#include "$2$3\.au3"$4')
    
    if DepTable[0][0] > 1 then __ReplaceOwnNames(text, module)
    __ReplaceNotOwnNames(text, module)


func __PreventReimporting(dim byref text, module)
; comment #import if module including or importing alredy been
    const rel_dirSlash = PathPart(DepTable[module][0], "dir")
    dim relrel_dep, foundInPrev
    for dep = 1 to DepTable[0][0]
        if DepTable[module][dep] <> ImportDep then continueloop
        relrel_dep = DepTable[dep][0]
        if rel_dirSlash <> "" then
            relrel_dep = Replace(relrel_dep, rel_dirSlash, "")
        relrel_dep = ReReplace(relrel_dep, "[\\.^$[({+#]", "\\$0")
        text = ReReplace(text, _
                '(?m)^\s*\#(include|import)\s+[<"]' _
                . relrel_dep _
                . '[>"]', _
                ";PLYS $0")
        foundInPrev = False
        for prev = 1 to module - 1
            if DepTable[prev][dep] then
                foundInPrev = True
                exitloop
        if not foundInPrev then  ; uncomment first
            text = ReReplace(text, '(?m)^;PLYS (\#(include|import)\s+[<"]' _
                    . relrel_dep . '[>"])', "$1", 1)


func __ReplaceOwnNames(dim byref text, module)
    const names = DepTable[0][module]
    if not IsArray(names) then return
    ; purified filename
    dim prefix = PathPart(DepTable[module][0], "dir", "name")
    prefix = ReReplace(prefix, "\W", "_")
    ; TODO: put names into pattern (name|name|…)
    ; and replace it in one fell swoop
    for name in names
        if Left(name, 1) = "$" then  ; is variable
            ReReplace(text, _
                    "(?im)([^\w""'" . NameDelimRegEx . "]|^)\$(" _
                        . TrimLeft(name, 1) . ")([^\w""'])", _
                    "$1\$" . prefix . "_$2$3")
        else  ; is function
            prefix = ReReplace(prefix, "^[0-9]", "_$1")
            ReReplace(text, _
                    "(?im)([^\w""'\$" . NameDelimRegEx . "]|^)(" . name _
                    . ")([^\w""'])", _
                    "${1}" . prefix . "_$2$3")


;··············································································
func __ReplaceNotOwnNames(dim byref text, module)
; replace names from ThruTable[0][dep] in module file
;··············································································
    const depTypes = [ImportDep, IncludeDep, MirIncludeDep]
    dim names
    dim filename, prefix, varPrefix, isPublic
    for depType in depTypes
        for dep = 1 to DepTable[0][0]
            if ThruTable[module][dep] <> depType then continueloop
            names = DepTable[0][dep]
            if not IsArray(names) then continueloop
            ; purified filename
            filename = PathPart(DepTable[dep][0], "name")
            filename = ReReplace(filename, "\W", "_")
            prefix = PathPart(DepTable[dep][0], "dir")
            prefix = ReReplace(prefix, "\W", "_")
            prefix .= filename
            for name in names
                if Left(name, 1) = "$" then  ; is variable
                    name = TrimLeft(name, 1)
                    varPrefix = "\$"
                else
                    prefix = ReReplace(prefix, "^[0-9]", "_$1")
                    varPrefix = ""
                if ReFind(name, PublicSuffixRegEx . "$") then
                    name = TrimRight(name, 1)
                    isPublic = True
                else
                    isPublic = False
                if ThruTable[module][dep] <> ImportDep then
                    ReReplace(text, _
                            "(?im)([^\w""']|^)" . varPrefix . name _
                            . "([^\w""'])", _
                            "${1}" . varPrefix . prefix . "_" . name _
                            . "$2")
                elseif isPublic then  ; ImportDep and isPublic
                    ReReplace(text, _
                            "(?im)([^\w""']|^)" . filename _
                            . NameDelimRegEx . varPrefix . name _
                            . "([^\w""'])", "${1}" . varPrefix . prefix _
                            . "_" . name . "$2")


;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
func _RenameSynonyms(dim byref text, isMainModule)
; TODO: remove Get prefixes
;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        ReReplace(text, "(?i)\bEcho\b", "ConsoleWrite")
        ; DllStruct ————————————————————————
        ReReplace(text, "(?i)\bStruct\b", "DllStructCreate")
        ReReplace(text, "(?i)\bStructGet\b", "DllStructGetData")
        ReReplace(text, "(?i)\bStructGetSize\b", "DllStructGetSize")
        ReReplace(text, "(?i)\bStructGetPtr\b", "DllStructGetPtr")
        ReReplace(text, "(?i)\bStructSet\b", "DllStructSetData")
        ReReplace(text, "(?i)\bIsStruct\b", "IsDllStruct")
        ; File —————————————————————————————
        ReReplace(text, "(?i)\b(" _
                . "ChangeDir|Copy|CreateShortcut|Flush|GetAttrib|" _
                . "GetEncoding|GetLongName|GetShortcut|GetShortName|GetSize|" _
                . "GetTime|GetVersion|Open|OpenDialog|Read|ReadLine|" _
                . "ReadToArray|Recycle|RecycleEmpty|SaveDialog|SelectFolder|" _
                . "SetAttrib|SetEnd|SetPos|SetTime|Write|WriteLine" _
                . ")\b", "File$1")
        ReReplace(text, "(?i)\bCreateLink\b", "FileCreateNTFSLink")
        ReReplace(text, "(?i)\bFirstFile\b", "FileFindFirstFile")
        ReReplace(text, "(?i)\bNextFile\b", "FileFindNextFile")
        ; **Close|**Delete|**Exists|**GetPos|Install|**Move
        ; String ———————————————————————————
        ReReplace(text, "(?i)\b(" _
                . "AddCR|Format|InStr|IsAlNum|IsAlpha|IsASCII|IsDigit|" _
                . "IsLower|IsSpace|IsUpper|IsXDigit|Left|Len|Lower|Mid|" _
                . "Replace|Right|Split|StripCR|StripWS|TrimLeft|TrimRight|" _
                . "Upper" _
                . ")\b", "String$1")
        ReReplace(text, "(?i)\bReFind\b", "StringRegExp")
        ReReplace(text, "(?i)\bReReplace\b", "StringRegExpReplace")
        ; Compare|FromASCIIArray|*IsFloat|*IsInt|**Reverse|ToASCIIArray
        ; Win ——————————————————————————————
        ReReplace(text, "(?i)\b(" _
                . "Activate|Active|Flash|GetCaretPos|GetClassList|" _
                . "GetClientSize|GetProcess|GetTitle|Kill|List|" _
                . "MenuSelectItem|MinimizeAll|MinimizeAllUndo|SetOnTop|" _
                . "SetTitle|SetTrans|Wait|WaitActive|WaitClose|WaitNotActive" _
                . ")\b", "Win$1")
        ; **Close|**Exists|*GetHandle|**GetPos|*GetState|*GetText|**Move
        ; |*SetState
        ; Macros ———————————————————————————
        ReReplace(text, "(?i)(@)(" _
                . "NoCaseSense|CaseSense|NoCaseSenseBasic|StripLeading|" _
                . "StripTrailing|StripSpaces|StripAll|ChrSplit|EntireSplit|" _
                . "NoCount|EndNotStart|UTF16|UCS2" _
                . ")\b", "$Str_$2")
        ReReplace(text, "(?i)(@Re)(" _
                . "Array|ArrayFull|ArrayGlobal|ArrayGlobalFull" _
                . ")\b", "$Str_RegExp$2Match")
        ReReplace(text, "(?i)@ReMatch\b", "$STR_REGEXPMATCH")
        ReReplace(text, "(?i)@ActiveWin\b", 'WinGetHandle("[ACTIVE]")')
        ReReplace(text, "(?i)@CmdLine\b", "$CmdLine")
        ReReplace(text, "@(\W)", "@CRLF$1")
        ; _Array ———————————————————————————
        ReReplace(text, "(?i)\b(" _
                . "Add|ColDelete|ColInsert|Combinations|Display|Extract|" _
                . "FindAll|Insert|Max|MaxIndex|Min|MinIndex|Permute|Pop|" _
                . "Push|Search|Shuffle|Sort|Swap|ToClip|Transpose|Trim|" _
                . "Unique" _
                . ")\b", "_Array$1")
        ; ReReplace(text, "(?i)\b(Filter|Map|Reduce)\b", "_Array$1")
        ReReplace(text, "(?i)\bToHistogram\b", "_Array1DToHistogram")
        ReReplace(text, "(?i)\bBinSearch\b", "_ArrayBinarySearch")
        ReReplace(text, "(?i)\bConcat\b", "_ArrayConcatenate")
        ; **Delete|**Reverse|*ToString
        ; ——————————————————————————————————
        ReReplace(text, "(\s)\.(\s)", "$1&$2")
        ReReplace(text, "\.=", "&=")
        if isMainModule then
            text = _ArrayToString(text, "", -1, -1, "", 0, 0)
            text = ReReplace(text, "(?im)^(?!#au)", _
                    "#include <StringConstants.au3>" . @ _
                    . "#include <Array.au3>" . @, 1); _
                    ; . "#include <Function.au3>" . @, 1)


func _CombineTokens(dim byref main, byref misc)
    main = Split(main, MainTokenDelim, @NoCount)
    dim text = ""
    for i = 0 to UBound(misc) - 1
        text .= main[i] . misc[i]
    main = text . main[i]


func ProcessStdio(pid)
    const proc = _WinAPI_OpenProcess( _
            (_WinAPI_GetVersion() >= 6.0)? _
            PROCESS_QUERY_LIMITED_INFORMATION _
            : PROCESS_QUERY_INFORMATION, 0, pid)
    const lastData = _WaitClose(pid)
    StdioClose(pid)
    if _WinAPI_GetExitCodeProcess(proc) = 0 then
        if not RapidMode then
            for path in PathsToDeleteOnExit
                FileDelete(path)
    elseif ErrorStdOut and lastData <> "" then
        ConsoleWrite(_FormatError(lastData))
    _WinAPI_CloseHandle(proc)


func _WaitClose(pid)
    dim timer = TimerInit()
    dim stdoutData, lastData = "", lastLoop = False
    while True
        StdinWrite(pid, ConsoleRead())
        ConsoleWriteError(StderrRead(pid))
        if ErrorStdOut then
            stdoutData = StdoutRead(pid)
            if stdoutData <> "" then lastData = stdoutData
            ConsoleWrite(stdoutData)
        else
            ConsoleWrite(StdoutRead(pid))
        if lastLoop then exitloop
        if TimerDiff(timer) > 300 then
            if not ProcessExists(pid) then lastLoop = True
            timer = TimerInit()
        GUIGetMsg()  ; prevents hogging of the CPU
    return lastData


func _FormatError(dim errorData)
    ; TODO: catch more than one error in message
    errorData = ReFind(errorData, _
            '[^"]*("?)([a-zA-Z]:\\.+?\.au[p3])(\.au3)("? \()(\d+)' _
            . '(\) : ==> )(.+?)\.: ?\R(.+\R)(.*)(\^ ERROR\R)$', _
            @ReArray)
    const line = ReadLine(errorData[1] . errorData[2], errorData[4])
    errorData[2] = ""
    errorData[4] = ReReplace(line, ".*?\t\t; #(\d+)$", "$1")
    errorData[6] .= ": " . TrimLeft(errorData[7], Len(errorData[8]))
    return _ArrayToString(errorData, "", 0, 6)



func PathPart(path, dim start="path", dim finish="")
; Select subpath from start to finish part
; if start="path" then returns original path
; if finish="" then returns start only
    const components = ["path", "drive", "dir", "name", "ext"]
    start = Search(components, start)
    if @error then start = 0
    finish = Search(components, finish)
    if @error then finish = start
    
    ; from _PathSplit (File.au3)
    dim split_ = ReFind(path, _
            "^\h*((?:\\\\\?\\)*(\\\\[^\?\/\\]+|[A-Za-z]:)?(.*[\/\\]\h*)?" _
            . "((?:[^\.\/\\]|(?(?=\.[^\/\\]*\.)\.))*)?([^\/\\]*))$", @ReArray)
    if @error then ; This error should never happen.
        redim split_[5]
        split_[0] = path
    split_[2] = ReReplace(split_[2], "\h*[\/\\]+\h*", _
            (Left(split_[2], 1) == "/")? "\/" : "\\")
    
    dim result = ""
    for i = start to finish
        result .= split_[i]
    return result
